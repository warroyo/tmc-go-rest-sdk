// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// ClusterDataprotectionRestoreSpec The restore spec.
//
// swagger:model cluster.dataprotection.restore.Spec
type ClusterDataprotectionRestoreSpec struct {

	// The name of the backup to restore from.
	// Deprecated, use backup_ref instead.
	BackupName string `json:"backupName,omitempty"`

	// Reference of the Backup to restore from.
	BackupRef *ClusterDataprotectionRestoreBackupReference `json:"backupRef,omitempty"`

	// The list of namespace names to be excluded from restore.
	ExcludedNamespaces []string `json:"excludedNamespaces"`

	// The list of resource names to be excluded from restore.
	ExcludedResources []string `json:"excludedResources"`

	// Specifies the restore behaviour for the kubernetes resource to be restored.
	ExistingResourcePolicy *ClusterDataprotectionRestoreSpecExistingResourcePolicyType `json:"existingResourcePolicy,omitempty"`

	// Hooks represent custom actions that should be executed during or post restore.
	Hooks *ClusterDataprotectionRestoreRestoreHooks `json:"hooks,omitempty"`

	// A flag which specifies whether cluster-scoped resources should be included for consideration in the restore.
	// If set to true, all cluster-scoped resources will be restored. If set to false, all cluster-scoped resources
	// will be excluded during the restore. If unset, all cluster-scoped resources are included if and only if all
	// namespaces are included and there are no excluded namespaces.
	// Otherwise, only cluster-scoped resources associated with namespace-scoped resources
	// included in the restore spec are restored. For example, if a PersistentVolumeClaim for a namespace is included
	// in the restore, its associated PersistentVolume (which is cluster-scoped) would also be restored.
	IncludeClusterResources bool `json:"includeClusterResources,omitempty"`

	// The list of namespace names to be included for restore. If empty, all namespaces are included.
	IncludedNamespaces []string `json:"includedNamespaces"`

	// The list of resource names to be included in the restore. If empty, all resources in the backup are included.
	IncludedResources []string `json:"includedResources"`

	// A label selector used to selectively restore individual objects from the backup. If empty
	// or nil, all objects are included. Optional.
	LabelSelector *K8sIoApimachineryPkgApisMetaV1LabelSelector `json:"labelSelector,omitempty"`

	// A map of source namespace names to target namespace names to restore into. Any source namespaces not
	// included in the map will be restored into namespaces of the same name.
	NamespaceMapping map[string]string `json:"namespaceMapping,omitempty"`

	// A list of metav1.LabelSelector to filter with when adding individual objects to the restore.
	// If multiple provided they will be joined by the OR operator. LabelSelector as well as
	// OrLabelSelectors cannot co-exist in backup request, only one of them can be used.
	OrLabelSelectors []*K8sIoApimachineryPkgApisMetaV1LabelSelector `json:"orLabelSelectors"`

	// Specifies whether to restore old nodePorts from the backup.
	PreserveNodePorts bool `json:"preserveNodePorts,omitempty"`

	// A flag which specifies whether to restore all included PVs from snapshot (via the cloudprovider). If set to true,
	// volumes will be restored. If set to false, volumes will not be restored. If left unset, volume restore will be
	// attempted if the backup had snapshots included and snapshot locations are configured for the cluster.
	RestorePvs bool `json:"restorePvs,omitempty"`

	// Specifies which resources we should restore the status field. If nil, no objects are included.
	RestoreStatus *ClusterDataprotectionRestoreResourceIncludesExcludes `json:"restoreStatus,omitempty"`

	// The name of the schedule to restore from. If specified, and BackupName is empty, the most recent successful
	// backup created from this schedule will be restored.
	ScheduleName string `json:"scheduleName,omitempty"`
}

// Validate validates this cluster dataprotection restore spec
func (m *ClusterDataprotectionRestoreSpec) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBackupRef(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExistingResourcePolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHooks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLabelSelector(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrLabelSelectors(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRestoreStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterDataprotectionRestoreSpec) validateBackupRef(formats strfmt.Registry) error {
	if swag.IsZero(m.BackupRef) { // not required
		return nil
	}

	if m.BackupRef != nil {
		if err := m.BackupRef.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("backupRef")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("backupRef")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterDataprotectionRestoreSpec) validateExistingResourcePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.ExistingResourcePolicy) { // not required
		return nil
	}

	if m.ExistingResourcePolicy != nil {
		if err := m.ExistingResourcePolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("existingResourcePolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("existingResourcePolicy")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterDataprotectionRestoreSpec) validateHooks(formats strfmt.Registry) error {
	if swag.IsZero(m.Hooks) { // not required
		return nil
	}

	if m.Hooks != nil {
		if err := m.Hooks.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hooks")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("hooks")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterDataprotectionRestoreSpec) validateLabelSelector(formats strfmt.Registry) error {
	if swag.IsZero(m.LabelSelector) { // not required
		return nil
	}

	if m.LabelSelector != nil {
		if err := m.LabelSelector.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("labelSelector")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("labelSelector")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterDataprotectionRestoreSpec) validateOrLabelSelectors(formats strfmt.Registry) error {
	if swag.IsZero(m.OrLabelSelectors) { // not required
		return nil
	}

	for i := 0; i < len(m.OrLabelSelectors); i++ {
		if swag.IsZero(m.OrLabelSelectors[i]) { // not required
			continue
		}

		if m.OrLabelSelectors[i] != nil {
			if err := m.OrLabelSelectors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("orLabelSelectors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("orLabelSelectors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterDataprotectionRestoreSpec) validateRestoreStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.RestoreStatus) { // not required
		return nil
	}

	if m.RestoreStatus != nil {
		if err := m.RestoreStatus.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("restoreStatus")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("restoreStatus")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cluster dataprotection restore spec based on the context it is used
func (m *ClusterDataprotectionRestoreSpec) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBackupRef(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExistingResourcePolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHooks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLabelSelector(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOrLabelSelectors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRestoreStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterDataprotectionRestoreSpec) contextValidateBackupRef(ctx context.Context, formats strfmt.Registry) error {

	if m.BackupRef != nil {
		if err := m.BackupRef.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("backupRef")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("backupRef")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterDataprotectionRestoreSpec) contextValidateExistingResourcePolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.ExistingResourcePolicy != nil {
		if err := m.ExistingResourcePolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("existingResourcePolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("existingResourcePolicy")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterDataprotectionRestoreSpec) contextValidateHooks(ctx context.Context, formats strfmt.Registry) error {

	if m.Hooks != nil {
		if err := m.Hooks.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hooks")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("hooks")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterDataprotectionRestoreSpec) contextValidateLabelSelector(ctx context.Context, formats strfmt.Registry) error {

	if m.LabelSelector != nil {
		if err := m.LabelSelector.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("labelSelector")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("labelSelector")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterDataprotectionRestoreSpec) contextValidateOrLabelSelectors(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.OrLabelSelectors); i++ {

		if m.OrLabelSelectors[i] != nil {
			if err := m.OrLabelSelectors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("orLabelSelectors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("orLabelSelectors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterDataprotectionRestoreSpec) contextValidateRestoreStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.RestoreStatus != nil {
		if err := m.RestoreStatus.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("restoreStatus")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("restoreStatus")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterDataprotectionRestoreSpec) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterDataprotectionRestoreSpec) UnmarshalBinary(b []byte) error {
	var res ClusterDataprotectionRestoreSpec
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
